name: Build and Package Winget Wingman

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (use latest: e.g., 1.2.0)'
        required: true
        type: string
      run_tests:
        description: 'Run tests before packaging'
        required: false
        default: true
        type: boolean
      dry_run:
        description: 'Dry run - package only, no GitHub release'
        required: false
        default: false
        type: boolean

jobs:
  test:
    if: ${{ inputs.run_tests }}
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup PowerShell modules
        shell: powershell
        run: |
          Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser
          Install-Module -Name Pester -Force -Scope CurrentUser

      - name: Run PSScriptAnalyzer
        shell: powershell
        run: |
          Write-Host "Running PSScriptAnalyzer..."
          $results = Invoke-ScriptAnalyzer -Path ".\Invoke-AppDeployToolkit.ps1" -Severity Error -ExcludeRule PSUseBOMForUnicodeEncodedFile
          if ($results) {
            $results | Format-Table -AutoSize
            throw "PSScriptAnalyzer found issues"
          }
          Write-Host "PSScriptAnalyzer passed"

  generate-changelog:
    runs-on: windows-latest
    needs: [test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    outputs:
      changelog: ${{ steps.changelog.outputs.changelog }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history

      - name: Generate changelog from commits
        id: changelog
        shell: pwsh
        run: |
          # Get the latest tag (previous version)
          $latestTag = git describe --tags --abbrev=0 2>$null
          if (-not $latestTag) {
            # If no tags exist, get commits from beginning
            $commitRange = "HEAD"
            $sinceText = "initial commit"
          } else {
            $commitRange = "$latestTag..HEAD"
            $sinceText = "version $latestTag"
          }
          
          Write-Host "Generating changelog for commits since $sinceText"
          Write-Host "Commit range: $commitRange"
          
          # Get commit messages since last tag
          $commits = git log $commitRange --pretty=format:"%h - %s" --reverse
          
          if (-not $commits) {
            Write-Host "No commits found since last tag"
            $changelogContent = "No changes since last release."
          } else {
            Write-Host "Found commits:"
            $commits | ForEach-Object { Write-Host "  $_" }
            
            # Build changelog
            $changelogLines = @()
            $changelogLines += "## What's Changed"
            $changelogLines += ""
            
            # Categorize commits
            $features = @()
            $fixes = @()
            $docs = @()
            $chores = @()
            $other = @()
            
            $commits | ForEach-Object {
              $commit = $_
              $message = $commit -replace '^\w+ - ', ''  # Remove hash prefix
              
              # Categorize based on commit message patterns
              if ($message -match '^(feat|feature)(\(.+\))?: ' -or $message -match '^Add ' -or $message -match '^Implement ') {
                $features += "- $message"
              } elseif ($message -match '^(fix|bugfix)(\(.+\))?: ' -or $message -match '^Fix ' -or $message -match '^Resolve ') {
                $fixes += "- $message"
              } elseif ($message -match '^(docs?)(\(.+\))?: ' -or $message -match '^Update README' -or $message -match '^Documentation') {
                $docs += "- $message"
              } elseif ($message -match '^(chore|build|ci)(\(.+\))?: ' -or $message -match '^Update version' -or $message -match '^Bump ') {
                $chores += "- $message"
              } else {
                $other += "- $message"
              }
            }
            
            # Add categorized sections
            if ($features.Count -gt 0) {
              $changelogLines += "### New Features"
              $changelogLines += $features
              $changelogLines += ""
            }
            
            if ($fixes.Count -gt 0) {
              $changelogLines += "### Bug Fixes"
              $changelogLines += $fixes
              $changelogLines += ""
            }
            
            if ($docs.Count -gt 0) {
              $changelogLines += "### Documentation"
              $changelogLines += $docs
              $changelogLines += ""
            }
            
            if ($other.Count -gt 0) {
              $changelogLines += "### Other Changes"
              $changelogLines += $other
              $changelogLines += ""
            }
            
            if ($chores.Count -gt 0) {
              $changelogLines += "### Maintenance"
              $changelogLines += $chores
              $changelogLines += ""
            }
            
            $changelogContent = $changelogLines -join "`n"
          }

          Write-Host "Generated changelog:"
          Write-Host $changelogContent
          
          # Escape for GitHub output (handle multiline)
          $escapedChangelog = $changelogContent -replace "`r`n", "`n" -replace "`r", "`n"
          echo "changelog=$escapedChangelog" >> $env:GITHUB_OUTPUT

  package:
    runs-on: windows-latest
    needs: [generate-changelog]
    if: always() && needs.generate-changelog.result == 'success'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Microsoft Win32 Content Prep Tool
        shell: pwsh
        run: |
          Write-Host "Downloading Microsoft Win32 Content Prep Tool..."
          $url = "https://github.com/Microsoft/Microsoft-Win32-Content-Prep-Tool/archive/refs/heads/master.zip"
          $outputPath = ".\prep-tool.zip"
          
          try {
            Invoke-WebRequest -Uri $url -OutFile $outputPath -UseBasicParsing
            Write-Host "Download completed"
            
            # Extract the zip file
            Expand-Archive -Path $outputPath -DestinationPath ".\prep-tool" -Force
            Write-Host "Extraction completed"
            
            # List contents to debug
            Write-Host "Contents of prep-tool directory:"
            Get-ChildItem -Path ".\prep-tool" -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
            
            # Find the actual executable with more thorough search
            $toolPath = Get-ChildItem -Path ".\prep-tool" -Filter "IntuneWinAppUtil.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
            
            if (-not $toolPath) {
              # Try alternative name
              $toolPath = Get-ChildItem -Path ".\prep-tool" -Filter "*.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
              Write-Host "Alternative exe found: $($toolPath.FullName)"
            }
            
            if ($toolPath) {
              Write-Host "Found tool at: $($toolPath.FullName)"
              # Make it executable (in case it's not)
              $toolPath.Attributes = $toolPath.Attributes -band (-bnot [System.IO.FileAttributes]::ReadOnly)
            } else {
              throw "Could not find IntuneWinAppUtil.exe or any executable in the downloaded package"
            }
          } catch {
            Write-Host "Error downloading/extracting tool: $_"
            throw
          }

      - name: Create staging directory and update version
        shell: pwsh
        run: |
          Write-Host "Creating staging directory..."
          
          # Create staging directory
          $stagingDir = ".\Staging"
          if (Test-Path $stagingDir) {
            Remove-Item $stagingDir -Recurse -Force
          }
          New-Item -Path $stagingDir -ItemType Directory -Force
          
          # Define folders and files to include (exclude .github, README, prep-tool, etc.)
          $foldersToInclude = @('Assets', 'Config', 'Files', 'PSAppDeployToolkit', 'PSAppDeployToolkit.Extensions', 'PSAppDeployToolkit.WinGet', 'Strings', 'SupportFiles')
          $filesToInclude = @('Invoke-AppDeployToolkit.exe', 'Invoke-AppDeployToolkit.ps1')
          
          # Copy folders
          foreach ($folder in $foldersToInclude) {
            if (Test-Path $folder) {
              $destPath = Join-Path $stagingDir $folder
              Write-Host "Copying folder: $folder -> $destPath"
              Copy-Item -Path $folder -Destination $destPath -Recurse -Force
            } else {
              Write-Host "Warning: Folder '$folder' not found, skipping"
            }
          }
          
          # Copy individual files
          foreach ($file in $filesToInclude) {
            if (Test-Path $file) {
              $destPath = Join-Path $stagingDir $file
              Write-Host "Copying file: $file -> $destPath"
              Copy-Item -Path $file -Destination $destPath -Force
            } else {
              Write-Host "Warning: File '$file' not found, skipping"
            }
          }
          
          Write-Host "Staging directory created successfully"
          
          # Update version and date in the staging copy
          $version = "${{ inputs.version }}"
          $scriptPath = Join-Path $stagingDir "Invoke-AppDeployToolkit.ps1"
          $today = Get-Date -Format "yyyy-MM-dd"
          
          Write-Host "Updating version to $version and date to $today in staging copy"
          
          # Read the staging script
          $content = Get-Content $scriptPath -Raw
          
          # Update version and date placeholders
          $content = $content -replace "AppScriptVersion\s*=\s*'PLACEHOLDER_VERSION'", "AppScriptVersion            = '$version'"
          $content = $content -replace "AppScriptDate\s*=\s*'PLACEHOLDER_DATE'", "AppScriptDate               = '$today'"
          
          # Write back to staging file
          Set-Content -Path $scriptPath -Value $content -Encoding UTF8BOM
          
          Write-Host "Version and date updated successfully in staging copy"
          
          # Verify the changes
          $updatedContent = Get-Content $scriptPath -Raw
          if ($updatedContent -match "AppScriptVersion\s*=\s*'$version'") {
            Write-Host "Version verification passed"
          } else {
            throw "Version update failed - version not found in updated content"
          }
          
          if ($updatedContent -match "AppScriptDate\s*=\s*'$today'") {
            Write-Host "Date verification passed"
          } else {
            throw "Date update failed - date not found in updated content"
          }
          
          # Debug: Show staging directory contents
          Write-Host "`n=== Staging Directory Contents ===" -ForegroundColor Yellow
          Get-ChildItem -Path $stagingDir -Recurse | ForEach-Object {
            $relativePath = $_.FullName.Replace("$stagingDir\", "")
            if ($_.PSIsContainer) {
              Write-Host "[DIR]  $relativePath" -ForegroundColor Cyan
            } else {
              $sizeMB = [math]::Round($_.Length / 1MB, 2)
              Write-Host "[FILE] $relativePath ($sizeMB MB)"
            }
          }
          
          # Calculate staging directory size
          $stagingSize = (Get-ChildItem -Path $stagingDir -Recurse -File | Measure-Object -Property Length -Sum).Sum
          Write-Host "`nStaging directory size: $([math]::Round($stagingSize / 1MB, 2)) MB" -ForegroundColor Green

      - name: Create Intune Win32 package
        shell: pwsh
        run: |
          Write-Host "Creating Intune Win32 package..."
          
          $version = "${{ inputs.version }}"
          $sourceFolder = ".\Staging"
          $setupFile = "Invoke-AppDeployToolkit.ps1"
          $outputFolder = ".\Output"
          $outputFile = "WingetWingman-$version.intunewin"
          
          # Create output directory
          New-Item -Path $outputFolder -ItemType Directory -Force
          
          # Find the IntuneWinAppUtil.exe with more robust search
          Write-Host "Searching for IntuneWinAppUtil.exe..."
          $toolPath = Get-ChildItem -Path ".\prep-tool" -Filter "IntuneWinAppUtil.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
          
          if (-not $toolPath) {
            # Fallback: look for any exe file
            $toolPath = Get-ChildItem -Path ".\prep-tool" -Filter "*.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($toolPath) {
              Write-Host "Found executable: $($toolPath.Name) at $($toolPath.FullName)"
            }
          }
          
          if (-not $toolPath) {
            Write-Host "Available files in prep-tool:"
            Get-ChildItem -Path ".\prep-tool" -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
            throw "Could not find IntuneWinAppUtil.exe or any executable file"
          }
          
          $toolFullPath = $toolPath.FullName
          Write-Host "Using tool at: $toolFullPath"
          
          # Verify the tool exists and is accessible
          if (-not (Test-Path $toolFullPath)) {
            throw "Tool path does not exist: $toolFullPath"
          }
          
          # Verify setup file exists in staging
          $setupFilePath = Join-Path $sourceFolder $setupFile
          if (-not (Test-Path $setupFilePath)) {
            Write-Host "ERROR: $setupFile not found in staging directory" -ForegroundColor Red
            Write-Host "Available files in staging:"
            Get-ChildItem -Path $sourceFolder | ForEach-Object { Write-Host "  $($_.Name)" }
            throw "Setup file not found in staging"
          }
          
          # Run the packaging tool
          $arguments = @("-c", "`"$sourceFolder`"", "-s", "`"$setupFile`"", "-o", "`"$outputFolder`"")
          Write-Host "Running: $toolFullPath $($arguments -join ' ')"
          
          try {
            $process = Start-Process -FilePath $toolFullPath -ArgumentList $arguments -Wait -NoNewWindow -PassThru
            Write-Host "Process exit code: $($process.ExitCode)"
            
            if ($process.ExitCode -ne 0) {
              throw "IntuneWinAppUtil.exe failed with exit code: $($process.ExitCode)"
            }
          } catch {
            Write-Host "Error running packaging tool: $_"
            throw
          }
          
          # Check if package was created
          Start-Sleep -Seconds 2
          $createdPackage = Get-ChildItem -Path $outputFolder -Filter "*.intunewin" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($createdPackage) {
            # Rename to our desired name
            $finalPath = Join-Path $outputFolder $outputFile
            if ($createdPackage.FullName -ne $finalPath) {
              Move-Item $createdPackage.FullName $finalPath -Force
            }
            Write-Host "Package created: $finalPath"
            
            # Get file size
            $fileSize = [math]::Round((Get-Item $finalPath).Length / 1MB, 2)
            Write-Host "Package size: $fileSize MB"
            
            # Set output for use in later steps
            echo "package-path=$finalPath" >> $env:GITHUB_OUTPUT
            echo "package-name=$outputFile" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "No .intunewin file found in output directory:"
            Get-ChildItem -Path $outputFolder | ForEach-Object { Write-Host "  $($_.Name)" }
            throw "Package creation failed - no .intunewin file found"
          }

      - name: Cleanup staging directory
        if: always()
        shell: pwsh
        run: |
          $stagingPath = ".\Staging"
          if (Test-Path $stagingPath) {
            Write-Host "Cleaning up staging directory: $stagingPath"
            Remove-Item -Path $stagingPath -Recurse -Force
            Write-Host "Staging directory cleaned up successfully"
          } else {
            Write-Host "Staging directory not found, nothing to clean up"
          }

      - name: Upload package as artifact (for dry run testing)
        uses: actions/upload-artifact@v4
        with:
          name: "WingetWingman-${{ inputs.version }}-Package"
          path: "./Output/WingetWingman-${{ inputs.version }}.intunewin"
          retention-days: 30

      - name: Create GitHub Release
        if: ${{ !inputs.dry_run }}
        uses: softprops/action-gh-release@v1
        with:
          tag_name: "${{ inputs.version }}"
          name: "Winget Wingman ${{ inputs.version }}"
          body: ${{ needs.generate-changelog.outputs.changelog }}
          files: |
            ./Output/WingetWingman-${{ inputs.version }}.intunewin
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Workflow Summary
        shell: pwsh
        run: |
          Write-Host ""
          Write-Host "Workflow completed successfully!" -ForegroundColor Green
          Write-Host ""
          if ("${{ inputs.dry_run }}" -eq "true") {
            Write-Host "DRY RUN MODE - No release created" -ForegroundColor Yellow
            Write-Host "Package available as workflow artifact for testing"
            Write-Host "Go to Actions -> this workflow run -> Artifacts to download"
            Write-Host "Run again without dry_run=true to create release"
          } else {
            Write-Host "GitHub Release created: v${{ inputs.version }}" -ForegroundColor Green
            Write-Host "Package ready for download from Releases page"
            Write-Host "Repository source files remain unchanged"
          }
          Write-Host ""
